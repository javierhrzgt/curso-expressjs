[
  {
    "projectId": "28353356-24fd-44ef-901b-631dcecded48",
    "testId": "b0638b83-92a3-45f4-98ec-4ddc0e6c59d0",
    "userId": "8498b498-d001-7001-aca9-4f55c3b5bfec",
    "title": "TC001-user registration with valid data",
    "description": "Test the user registration endpoint with valid name, email, and password to ensure a new user is created successfully and the password is hashed.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3001\"\nREGISTER_ENDPOINT = \"/api/v1/auth/register\"\nLOGIN_ENDPOINT = \"/api/v1/auth/login\"\n\nAUTH_USERNAME = \"javier@jvha.com\"\nAUTH_PASSWORD = \"Pass1234\"\nTIMEOUT = 30\n\ndef test_user_registration_with_valid_data():\n    # User registration data\n    user_data = {\n        \"name\": \"Test User\",\n        \"email\": \"testuser_valid@example.com\",\n        \"password\": \"ValidPass123\"\n    }\n\n    # Headers\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Basic Auth for the request\n    auth = HTTPBasicAuth(AUTH_USERNAME, AUTH_PASSWORD)\n\n    # Register the user\n    response = requests.post(\n        BASE_URL + REGISTER_ENDPOINT,\n        json=user_data,\n        headers=headers,\n        auth=auth,\n        timeout=TIMEOUT\n    )\n    \n    # Assert status code 201 Created\n    assert response.status_code == 201, f\"Expected status code 201, got {response.status_code}\"\n\n    # Login with the same user to verify password hashing indirectly (successful login means password was stored correctly)\n    login_data = {\n        \"email\": user_data[\"email\"],\n        \"password\": user_data[\"password\"]\n    }\n    login_response = requests.post(\n        BASE_URL + LOGIN_ENDPOINT,\n        json=login_data,\n        headers=headers,\n        auth=auth,\n        timeout=TIMEOUT\n    )\n\n    # Assert login succeeded and token returned\n    assert login_response.status_code == 200, f\"Expected status 200 on login, got {login_response.status_code}\"\n    login_json = login_response.json()\n    assert \"token\" in login_json and isinstance(login_json[\"token\"], str) and len(login_json[\"token\"]) > 0, \"Login response missing JWT token\"\n\n    # Cleanup: Delete the created user using login token if API supported user deletion (not specified, so skipping)\n\ntest_user_registration_with_valid_data()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-22T04:45:04.424Z",
    "modified": "2025-12-22T04:45:34.411Z"
  },
  {
    "projectId": "28353356-24fd-44ef-901b-631dcecded48",
    "testId": "d7182f6b-845e-49e5-b747-85e41ba8923a",
    "userId": "8498b498-d001-7001-aca9-4f55c3b5bfec",
    "title": "TC002-user login with correct credentials",
    "description": "Test the user login endpoint with valid email and password to verify that authentication succeeds and a JWT token is returned.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3001\"\nLOGIN_ENDPOINT = \"/api/v1/auth/login\"\nTIMEOUT = 30\n\n\ndef test_user_login_with_correct_credentials():\n    url = BASE_URL + LOGIN_ENDPOINT\n    payload = {\n        \"email\": \"javier@jvha.com\",\n        \"password\": \"Pass1234\"\n    }\n    try:\n        response = requests.post(url, json=payload, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected 200 OK, got {response.status_code}\"\n\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    assert \"token\" in data, \"JWT token not found in response\"\n    assert isinstance(data[\"token\"], str) and len(data[\"token\"]) > 0, \"JWT token is empty or invalid\"\n\n\ntest_user_login_with_correct_credentials()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-22T04:45:04.432Z",
    "modified": "2025-12-22T04:45:37.371Z"
  },
  {
    "projectId": "28353356-24fd-44ef-901b-631dcecded48",
    "testId": "e5c72c40-42d4-41ec-b8c4-be2c37a2bfb8",
    "userId": "8498b498-d001-7001-aca9-4f55c3b5bfec",
    "title": "TC003-access protected route with valid token",
    "description": "Test accessing a protected route with a valid JWT token to confirm access is granted and unauthorized access is rejected without a token.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3001\"\nUSERNAME = \"javier@jvha.com\"\nPASSWORD = \"Pass1234\"\nTIMEOUT = 30\n\ndef test_access_protected_route_with_valid_token():\n    login_url = f\"{BASE_URL}/api/v1/auth/login\"\n    protected_url = f\"{BASE_URL}/api/v1/auth/protected-route\"\n\n    # Step 1: Login to get a JWT token\n    login_payload = {\n        \"email\": USERNAME,\n        \"password\": PASSWORD\n    }\n\n    try:\n        login_response = requests.post(login_url, json=login_payload, timeout=TIMEOUT)\n        assert login_response.status_code == 200, f\"Expected 200 OK from login, got {login_response.status_code}\"\n        login_data = login_response.json()\n        assert \"token\" in login_data, \"Login response JSON does not contain 'token'\"\n        token = login_data[\"token\"]\n        assert isinstance(token, str) and len(token) > 0, \"Received token is empty or not a string\"\n\n        headers_with_token = {\"Authorization\": f\"Bearer {token}\"}\n\n        # Step 2: Access protected route with valid token\n        protected_response = requests.get(protected_url, headers=headers_with_token, timeout=TIMEOUT)\n        assert protected_response.status_code == 200, f\"Expected 200 OK from protected route with valid token, got {protected_response.status_code}\"\n\n        # Step 3: Access protected route without token - should be unauthorized\n        protected_response_no_token = requests.get(protected_url, timeout=TIMEOUT)\n        # Expecting 401 Unauthorized or similar\n        assert protected_response_no_token.status_code == 401, (\n            f\"Expected 401 Unauthorized from protected route without token, got {protected_response_no_token.status_code}\"\n        )\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_access_protected_route_with_valid_token()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-22T04:45:04.438Z",
    "modified": "2025-12-22T04:45:35.765Z"
  },
  {
    "projectId": "28353356-24fd-44ef-901b-631dcecded48",
    "testId": "dc3fc929-fb69-4a20-bb9c-857ea8b99aed",
    "userId": "8498b498-d001-7001-aca9-4f55c3b5bfec",
    "title": "TC004-admin create time block with valid data",
    "description": "Test the admin endpoint for creating time blocks with valid start and end times and verify that only users with ADMIN role can create time blocks.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nfrom datetime import datetime, timedelta, timezone\n\nBASE_URL = \"http://localhost:3001\"\nAUTH_USERNAME = \"javier@jvha.com\"\nAUTH_PASSWORD = \"Pass1234\"\nTIMEOUT = 30\n\ndef parse_datetime(dt_str):\n    # Normalize datetime strings by parsing them\n    # Accept with or without 'Z' suffix\n    try:\n        if dt_str.endswith('Z'):\n            dt_str = dt_str[:-1] + '+00:00'\n        return datetime.fromisoformat(dt_str)\n    except Exception:\n        return None\n\ndef test_admin_create_time_block_with_valid_data():\n    # Step 1: Authenticate and obtain JWT token via login endpoint\n    login_url = f\"{BASE_URL}/api/v1/auth/login\"\n    login_payload = {\n        \"email\": AUTH_USERNAME,\n        \"password\": AUTH_PASSWORD\n    }\n    try:\n        login_response = requests.post(login_url, json=login_payload, timeout=TIMEOUT)\n        assert login_response.status_code == 200, f\"Login failed with status {login_response.status_code}\"\n        login_data = login_response.json()\n        token = login_data.get(\"token\")\n        assert token, \"No token received after login\"\n    except Exception as e:\n        raise AssertionError(f\"Exception during login: {e}\")\n\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Step 2: Prepare valid time block data - startTime and endTime in ISO 8601 format\n    start_time_obj = (datetime.utcnow() + timedelta(hours=1)).replace(microsecond=0).replace(tzinfo=timezone.utc)\n    end_time_obj = (datetime.utcnow() + timedelta(hours=2)).replace(microsecond=0).replace(tzinfo=timezone.utc)\n    start_time = start_time_obj.isoformat().replace('+00:00', 'Z')\n    end_time = end_time_obj.isoformat().replace('+00:00', 'Z')\n    time_block_payload = {\n        \"startTime\": start_time,\n        \"endTime\": end_time\n    }\n\n    time_blocks_url = f\"{BASE_URL}/api/v1/admin/time-blocks\"\n\n    # Step 3: Attempt to create time block with admin token\n    try:\n        create_response = requests.post(time_blocks_url, json=time_block_payload, headers=headers, timeout=TIMEOUT)\n        assert create_response.status_code == 201, f\"Expected 201 Created but got {create_response.status_code}\"\n        created_block = create_response.json()\n        # Validate returned resource has startTime and endTime matching the request by datetime values\n        resp_start = parse_datetime(created_block.get(\"startTime\"))\n        resp_end = parse_datetime(created_block.get(\"endTime\"))\n        assert resp_start is not None, \"startTime missing or invalid in response\"\n        assert resp_end is not None, \"endTime missing or invalid in response\"\n        # Compare datetimes ignoring formatting differences\n        assert resp_start == start_time_obj, f\"startTime mismatch in response: expected {start_time_obj}, got {resp_start}\"\n        assert resp_end == end_time_obj, f\"endTime mismatch in response: expected {end_time_obj}, got {resp_end}\"\n        time_block_id = created_block.get(\"id\")\n        assert time_block_id, \"Created time block has no id\"\n    except Exception as e:\n        raise AssertionError(f\"Exception during creating time block as admin: {e}\")\n\n    # Step 4: Negative test - attempt creation with non-admin user\n    # Register and login a normal user (non-admin)\n    register_url = f\"{BASE_URL}/api/v1/auth/register\"\n    normal_user_email = \"normaluser_test_tc004@example.com\"\n    normal_user_password = \"UserPass123\"\n    normal_user_name = \"Normal User TC004\"\n\n    try:\n        # Register normal user (ignore if already exists)\n        reg_payload = {\n            \"name\": normal_user_name,\n            \"email\": normal_user_email,\n            \"password\": normal_user_password\n        }\n        reg_response = requests.post(register_url, json=reg_payload, timeout=TIMEOUT)\n        # 201 Created or 400 if user already exists\n        assert reg_response.status_code in (201, 400), f\"Unexpected registration status: {reg_response.status_code}\"\n    except Exception as e:\n        raise AssertionError(f\"Exception during normal user registration: {e}\")\n\n    # Login normal user\n    try:\n        login_payload_normal = {\n            \"email\": normal_user_email,\n            \"password\": normal_user_password\n        }\n        login_response_normal = requests.post(login_url, json=login_payload_normal, timeout=TIMEOUT)\n        assert login_response_normal.status_code == 200, f\"Normal user login failed: {login_response_normal.status_code}\"\n        token_normal = login_response_normal.json().get(\"token\")\n        assert token_normal, \"No token received for normal user\"\n    except Exception as e:\n        raise AssertionError(f\"Exception during normal user login: {e}\")\n\n    headers_normal = {\n        \"Authorization\": f\"Bearer {token_normal}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Attempt to create time block with normal user token - should be forbidden\n    try:\n        create_response_normal = requests.post(time_blocks_url, json=time_block_payload, headers=headers_normal, timeout=TIMEOUT)\n        assert create_response_normal.status_code == 403, \\\n            f\"Expected 403 Forbidden for non-admin user but got {create_response_normal.status_code}\"\n    except Exception as e:\n        raise AssertionError(f\"Exception during creating time block as non-admin user: {e}\")\n\n    # Cleanup: Delete created time block by admin\n    delete_url = f\"{time_blocks_url}/{time_block_id}\"\n    try:\n        delete_response = requests.delete(delete_url, headers=headers, timeout=TIMEOUT)\n        # Assume 204 No Content on successful deletion\n        assert delete_response.status_code in (200, 204), f\"Failed to delete time block, status {delete_response.status_code}\"\n    except Exception as e:\n        raise AssertionError(f\"Exception during cleanup deleting time block: {e}\")\n\ntest_admin_create_time_block_with_valid_data()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 122, in test_admin_create_time_block_with_valid_data\nAssertionError: Failed to delete time block, status 404\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 126, in <module>\n  File \"<string>\", line 124, in test_admin_create_time_block_with_valid_data\nAssertionError: Exception during cleanup deleting time block: Failed to delete time block, status 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-22T04:45:04.448Z",
    "modified": "2025-12-22T04:46:46.936Z"
  },
  {
    "projectId": "28353356-24fd-44ef-901b-631dcecded48",
    "testId": "9ea7b21f-73af-4e14-8cbf-288b7a06af90",
    "userId": "8498b498-d001-7001-aca9-4f55c3b5bfec",
    "title": "TC005-admin list all reservations",
    "description": "Test the admin endpoint to list all reservations ensuring only ADMIN role users can access the list and the response contains all reservations.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3001\"\nUSERNAME = \"javier@jvha.com\"\nPASSWORD = \"Pass1234\"\nTIMEOUT = 30\n\ndef test_admin_list_all_reservations():\n    \"\"\"\n    Test the admin endpoint to list all reservations ensuring only ADMIN role users can access the list and the response contains all reservations.\n    \"\"\"\n    login_url = f\"{BASE_URL}/api/v1/auth/login\"\n    reservations_url = f\"{BASE_URL}/api/v1/admin/reservations\"\n\n    # Step 1: Authenticate and get JWT token using basic auth\n    login_payload = {\n        \"email\": USERNAME,\n        \"password\": PASSWORD\n    }\n\n    try:\n        login_response = requests.post(login_url, json=login_payload, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Login request failed: {e}\"\n\n    assert login_response.status_code == 200, f\"Login failed with status code {login_response.status_code}\"\n\n    login_data = login_response.json()\n    token = login_data.get(\"token\", None)\n    assert token is not None and isinstance(token, str) and token.strip() != \"\", \"JWT token not found in login response\"\n\n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n\n    # Step 2: Request to list all reservations as ADMIN\n    try:\n        reservations_response = requests.get(reservations_url, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Reservations list request failed: {e}\"\n\n    # Successful response expected for ADMIN role\n    assert reservations_response.status_code == 200, f\"Listing reservations failed with status code {reservations_response.status_code}\"\n\n    # Validate response content (should be a list of reservations)\n    try:\n        reservations_data = reservations_response.json()\n    except ValueError:\n        assert False, \"Response is not a valid JSON\"\n\n    assert isinstance(reservations_data, list), \"Reservations response is not a list\"\n\n    # Optional: Each item in the list should be a dict representing a reservation (basic check)\n    if len(reservations_data) > 0:\n        for reservation in reservations_data:\n            assert isinstance(reservation, dict), \"Each reservation item should be a dictionary\"\n            # Optionally check for typical reservation fields like 'id', 'date', 'timeBlockId'\n            assert \"id\" in reservation, \"Reservation missing 'id' field\"\n            assert \"date\" in reservation, \"Reservation missing 'date' field\"\n\ndef run():\n    test_admin_list_all_reservations()\n\nrun()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-22T04:45:04.455Z",
    "modified": "2025-12-22T04:45:36.855Z"
  },
  {
    "projectId": "28353356-24fd-44ef-901b-631dcecded48",
    "testId": "a3e4fd5c-525c-4747-bc64-707a541f8c24",
    "userId": "8498b498-d001-7001-aca9-4f55c3b5bfec",
    "title": "TC006-create reservation with valid data",
    "description": "Test the reservation creation endpoint with valid date and time block ID for an authenticated user to ensure the reservation is created successfully.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nimport datetime\n\nBASE_URL = \"http://localhost:3001\"\nAUTH_ENDPOINT = \"/api/v1/auth/login\"\nRESERVATION_ENDPOINT = \"/api/v1/reservations\"\n\nUSERNAME = \"javier@jvha.com\"\nPASSWORD = \"Pass1234\"\nTIMEOUT = 30\n\ndef test_create_reservation_with_valid_data():\n    # Login to get JWT token\n    login_payload = {\n        \"email\": USERNAME,\n        \"password\": PASSWORD\n    }\n    login_resp = requests.post(\n        BASE_URL + AUTH_ENDPOINT,\n        json=login_payload,\n        timeout=TIMEOUT\n    )\n    assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n    token = login_resp.json().get(\"token\")\n    assert token and isinstance(token, str), \"JWT token missing or invalid\"\n\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Since we don't have a timeBlockId provided, we must first create a time block or retrieve an existing one.\n    # The PRD indicates only admin can create time blocks, we don't have admin credentials here.\n    # So we'll attempt to list reservations and use an existing timeBlockId from an existing reservation or create a dummy reservation with a fixed future date and timeBlockId 1 if fails.\n\n    # For this test, let's assume timeBlockId = 1 and future date. We do the test with that.\n    # Normally, this should be retrieved dynamically, but for this test scenario, we use a fixed known timeBlockId.\n\n    future_date = (datetime.datetime.utcnow() + datetime.timedelta(days=1)).strftime(\"%Y-%m-%dT%H:%M:%S\") + \"Z\"  # ISO 8601\n    reservation_payload = {\n        \"date\": future_date,\n        \"timeBlockId\": 1\n    }\n\n    reservation_id = None\n    try:\n        resp = requests.post(\n            BASE_URL + RESERVATION_ENDPOINT,\n            headers=headers,\n            json=reservation_payload,\n            timeout=TIMEOUT\n        )\n        assert resp.status_code == 201, f\"Failed to create reservation: {resp.status_code} {resp.text}\"\n        data = resp.json()\n        # The specification doesn't explicitly define the response body for reservation creation,\n        # but typically it returns the created resource including an ID.\n        # We'll try to get id from it.\n        reservation_id = data.get(\"id\")\n        assert reservation_id is not None, \"Created reservation ID missing in response\"\n    finally:\n        # Cleanup: delete the reservation if it was created\n        if reservation_id:\n            del_resp = requests.delete(\n                f\"{BASE_URL}{RESERVATION_ENDPOINT}/{reservation_id}\",\n                headers=headers,\n                timeout=TIMEOUT\n            )\n            # Deletion success 204 or 404 if already deleted\n            assert del_resp.status_code in (204, 404), f\"Failed to delete reservation in cleanup: {del_resp.status_code} {del_resp.text}\"\n\ntest_create_reservation_with_valid_data()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-22T04:45:04.463Z",
    "modified": "2025-12-22T04:45:39.834Z"
  },
  {
    "projectId": "28353356-24fd-44ef-901b-631dcecded48",
    "testId": "d5699e9c-059a-4c79-a806-2d3e561a88a2",
    "userId": "8498b498-d001-7001-aca9-4f55c3b5bfec",
    "title": "TC007-get reservation by id with authorization",
    "description": "Test retrieving a reservation by ID ensuring that users can only access their own reservations and receive appropriate errors for unauthorized access or non-existent reservations.",
    "code": "import requests\nimport datetime\nimport time\n\nBASE_URL = \"http://localhost:3001\"\nLOGIN_URL = f\"{BASE_URL}/api/v1/auth/login\"\nRESERVATIONS_URL = f\"{BASE_URL}/api/v1/reservations\"\n\nUSERNAME = \"javier@jvha.com\"\nPASSWORD = \"Pass1234\"\nTIMEOUT = 30\n\ndef test_get_reservation_by_id_with_authorization():\n    # Step 1: Login to get JWT token\n    try:\n        login_resp = requests.post(\n            LOGIN_URL,\n            json={\"email\": USERNAME, \"password\": PASSWORD},\n            timeout=TIMEOUT\n        )\n        assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n        token = login_resp.json().get(\"token\")\n        assert token and isinstance(token, str), \"No valid token received\"\n    except Exception as e:\n        raise AssertionError(f\"Login request failed: {str(e)}\")\n\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Step 2: Create a time block as admin is needed for reservation, but admin credentials are unknown here.\n    # Since no admin credentials given, test creation of reservation directly assuming a valid timeBlockId is known.\n    # We attempt to find an existing timeBlockId by creating a reservation and deleting it after test.\n\n    # For test purposes, pick a future date and a plausible existing timeBlockId (e.g. 1)\n    # If no such id, test might fail; ideally API provides an endpoint to list time blocks.\n\n    # We will try timeBlockId=1 here (likely for demo). Adjust if needed.\n    time_block_id = 1\n    reservation_date = (datetime.datetime.utcnow() + datetime.timedelta(days=1)).replace(microsecond=0).isoformat() + \"Z\"\n\n    reservation_id = None\n    try:\n        # Create reservation to own by the user for test\n        create_resp = requests.post(\n            RESERVATIONS_URL,\n            headers=headers,\n            json={\"date\": reservation_date, \"timeBlockId\": time_block_id},\n            timeout=TIMEOUT\n        )\n        assert create_resp.status_code == 201, f\"Failed to create reservation, status {create_resp.status_code}\"\n        reservation_id = create_resp.json().get(\"id\")\n        assert reservation_id is not None, \"Created reservation response missing id\"\n\n        # Step 3: Get reservation by ID - should succeed\n        get_resp = requests.get(\n            f\"{RESERVATIONS_URL}/{reservation_id}\",\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert get_resp.status_code == 200, f\"Failed to get reservation by ID, status {get_resp.status_code}\"\n        reservation_data = get_resp.json()\n        assert reservation_data.get(\"id\") == reservation_id, \"Returned reservation ID mismatch\"\n        # Additional checks could include validating user ownership, date and timeBlockId correctness\n\n        # Step 4: Attempt unauthorized access: No token\n        get_unauth_resp = requests.get(\n            f\"{RESERVATIONS_URL}/{reservation_id}\",\n            timeout=TIMEOUT\n        )\n        assert get_unauth_resp.status_code in (401, 403), f\"Unauthorized access allowed without token, status {get_unauth_resp.status_code}\"\n\n        # Step 5: Attempt access with invalid token\n        invalid_headers = {\n            \"Authorization\": \"Bearer invalidtoken123\",\n            \"Content-Type\": \"application/json\"\n        }\n        get_invalid_token_resp = requests.get(\n            f\"{RESERVATIONS_URL}/{reservation_id}\",\n            headers=invalid_headers,\n            timeout=TIMEOUT\n        )\n        assert get_invalid_token_resp.status_code in (401, 403), f\"Access allowed with invalid token, status {get_invalid_token_resp.status_code}\"\n\n        # Step 6: Attempt access to a non-existent reservation ID (e.g. very large number)\n        non_existent_id = 999999999\n        get_non_exist_resp = requests.get(\n            f\"{RESERVATIONS_URL}/{non_existent_id}\",\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert get_non_exist_resp.status_code == 404, f\"Non-existent reservation did not return 404, status {get_non_exist_resp.status_code}\"\n\n        # Step 7: Attempt access to a reservation owned by another user.\n        # Since we have no info about another user or their reservation, we simulate by trying to get an ID that likely exists but not owned.\n        # As a fallback, create another user and their reservation - but test plan doesn't include that.\n        # So we skip explicit test for another user's reservation here due to lack of credentials/data.\n\n    finally:\n        # Cleanup: Delete the created reservation if it exists\n        if reservation_id:\n            try:\n                delete_resp = requests.delete(\n                    f\"{RESERVATIONS_URL}/{reservation_id}\",\n                    headers=headers,\n                    timeout=TIMEOUT\n                )\n                assert delete_resp.status_code == 204, f\"Failed to delete reservation in cleanup, status {delete_resp.status_code}\"\n            except Exception:\n                pass\n\ntest_get_reservation_by_id_with_authorization()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-22T04:45:04.474Z",
    "modified": "2025-12-22T04:45:46.204Z"
  },
  {
    "projectId": "28353356-24fd-44ef-901b-631dcecded48",
    "testId": "b76dbd75-4d52-410b-809e-7d89ee5ef652",
    "userId": "8498b498-d001-7001-aca9-4f55c3b5bfec",
    "title": "TC008-update reservation with valid changes",
    "description": "Test updating an existing reservation with valid date and time block ID by the owner user and verify the update is successful and unauthorized updates are rejected.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nfrom datetime import datetime, timedelta\n\nBASE_URL = \"http://localhost:3001\"\nAUTH_CREDENTIALS = (\"javier@jvha.com\", \"Pass1234\")\nTIMEOUT = 30\n\ndef test_update_reservation_with_valid_changes():\n    session = requests.Session()\n    session.auth = HTTPBasicAuth(*AUTH_CREDENTIALS)\n    headers = {\"Content-Type\": \"application/json\"}\n    \n    # Helper function to create a time block as admin (needed for valid timeBlockId)\n    def create_time_block():\n        # Admin credentials assumed (for creating time blocks)\n        admin_auth = HTTPBasicAuth(\"admin@admin.com\", \"AdminPass123\")  # Assuming admin exists\n        start_time = datetime.utcnow() + timedelta(days=1, hours=9)\n        end_time = start_time + timedelta(hours=1)\n        payload = {\n            \"startTime\": start_time.isoformat() + \"Z\",\n            \"endTime\": end_time.isoformat() + \"Z\"\n        }\n        resp = requests.post(f\"{BASE_URL}/api/v1/admin/time-blocks\", \n                             json=payload, auth=admin_auth, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp.json()[\"id\"] if \"id\" in resp.json() else None\n\n    # Create a time block to use for reservation creation and update\n    time_block_id = None\n    try:\n        # Try to create time block for update testing\n        # If admin credentials unknown/absent, fallback to get any existing time block from user reservations or skip tests\n        time_block_id = create_time_block()\n    except Exception:\n        # If cannot create time block, skip test by raising error\n        raise RuntimeError(\"Failed to create time block needed for test.\")\n\n    assert time_block_id is not None, \"Time block ID must not be None\"\n\n    # Step 1: Create a reservation with initial date and timeBlockId\n    initial_date = (datetime.utcnow() + timedelta(days=2)).replace(hour=10, minute=0, second=0, microsecond=0).isoformat() + \"Z\"\n    reservation_payload = {\n        \"date\": initial_date,\n        \"timeBlockId\": time_block_id\n    }\n    create_resp = session.post(f\"{BASE_URL}/api/v1/reservations\", json=reservation_payload, headers=headers, timeout=TIMEOUT)\n    assert create_resp.status_code == 201, f\"Reservation creation failed: {create_resp.text}\"\n    reservation = create_resp.json()\n    reservation_id = reservation.get(\"id\")\n    assert reservation_id is not None, \"Created reservation should have an ID\"\n\n    try:\n        # Step 2: Update the reservation with a new date and same timeBlockId\n        updated_date = (datetime.utcnow() + timedelta(days=3)).replace(hour=11, minute=0, second=0, microsecond=0).isoformat() + \"Z\"\n        update_payload = {\n            \"date\": updated_date,\n            \"timeBlockId\": time_block_id\n        }\n        update_resp = session.put(f\"{BASE_URL}/api/v1/reservations/{reservation_id}\", json=update_payload, headers=headers, timeout=TIMEOUT)\n        assert update_resp.status_code == 200, f\"Reservation update failed: {update_resp.text}\"\n        updated_reservation = update_resp.json()\n        assert updated_reservation.get(\"date\") == updated_date, \"Reservation date was not updated correctly\"\n        assert updated_reservation.get(\"timeBlockId\") == time_block_id, \"Reservation timeBlockId was not updated correctly\"\n\n        # Step 3: Attempt unauthorized update on the reservation using another user credentials\n        other_user_auth = HTTPBasicAuth(\"otheruser@example.com\", \"OtherPass123\")  # Assuming this user exists and is different\n        other_session = requests.Session()\n        other_session.auth = other_user_auth\n        other_update_resp = other_session.put(f\"{BASE_URL}/api/v1/reservations/{reservation_id}\", json=update_payload, headers=headers, timeout=TIMEOUT)\n        assert other_update_resp.status_code in (401, 403), \"Unauthorized update should be rejected\"\n\n    finally:\n        # Cleanup: Delete the reservation created for the test\n        del_resp = session.delete(f\"{BASE_URL}/api/v1/reservations/{reservation_id}\", headers=headers, timeout=TIMEOUT)\n        assert del_resp.status_code == 204 or del_resp.status_code == 404, f\"Failed to delete reservation: {del_resp.text}\"\n\ntest_update_reservation_with_valid_changes()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 34, in test_update_reservation_with_valid_changes\n  File \"<string>\", line 26, in create_time_block\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 403 Client Error: Forbidden for url: http://localhost:3001/api/v1/admin/time-blocks\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 78, in <module>\n  File \"<string>\", line 37, in test_update_reservation_with_valid_changes\nRuntimeError: Failed to create time block needed for test.\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-22T04:45:04.487Z",
    "modified": "2025-12-22T04:45:48.581Z"
  },
  {
    "projectId": "28353356-24fd-44ef-901b-631dcecded48",
    "testId": "94b877b0-d8dd-46d9-9db5-27a1c43b70c9",
    "userId": "8498b498-d001-7001-aca9-4f55c3b5bfec",
    "title": "TC009-delete reservation by owner user",
    "description": "Test deleting a reservation by its owner user to confirm the reservation is deleted successfully and unauthorized deletion attempts are rejected.",
    "code": "import requests\nimport datetime\nimport traceback\n\nBASE_URL = \"http://localhost:3001\"\nAUTH_CREDENTIALS = (\"javier@jvha.com\", \"Pass1234\")\nTIMEOUT = 30\n\ndef test_delete_reservation_by_owner_user():\n    session = requests.Session()\n    # Authenticate user to get JWT token\n    try:\n        login_resp = session.post(\n            f\"{BASE_URL}/api/v1/auth/login\",\n            json={\"email\": AUTH_CREDENTIALS[0], \"password\": AUTH_CREDENTIALS[1]},\n            timeout=TIMEOUT,\n        )\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        token = login_resp.json().get(\"token\")\n        assert token, \"No token returned from login\"\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        \n        # Get list of user's own reservations to find a reservation to delete\n        # Since no direct endpoint provided, create one for testing:\n        # Create a time block as admin for reservation creation - Not required, use fixed timeBlockId=1 for test if exists\n        # Assumption: timeBlockId=1 exists and is available, else get one by listing or failing test.\n        \n        # Create a reservation to ensure we have one owned by user\n        reservation_payload = {\n            \"date\": (datetime.datetime.utcnow() + datetime.timedelta(days=1)).isoformat() + \"Z\",\n            \"timeBlockId\": 1\n        }\n        create_resp = session.post(\n            f\"{BASE_URL}/api/v1/reservations\",\n            headers=headers,\n            json=reservation_payload,\n            timeout=TIMEOUT,\n        )\n        assert create_resp.status_code == 201, f\"Failed to create reservation: {create_resp.text}\"\n        reservation = create_resp.json()\n        reservation_id = reservation.get(\"id\")\n        assert reservation_id is not None, \"Created reservation ID missing\"\n        \n        try:\n            # Now delete the reservation as its owner\n            delete_resp = session.delete(\n                f\"{BASE_URL}/api/v1/reservations/{reservation_id}\",\n                headers=headers,\n                timeout=TIMEOUT,\n            )\n            assert delete_resp.status_code == 204, f\"Failed to delete reservation: {delete_resp.text}\"\n\n            # Verify the reservation no longer exists\n            get_resp = session.get(\n                f\"{BASE_URL}/api/v1/reservations/{reservation_id}\",\n                headers=headers,\n                timeout=TIMEOUT,\n            )\n            assert get_resp.status_code == 404, \"Deleted reservation still accessible\"\n\n            # Attempt unauthorized deletion - try to delete another user's reservation id=999999 assuming it exists\n            # We expect 404 or 403; 404 is per API spec for not found\n            unauthorized_delete_resp = session.delete(\n                f\"{BASE_URL}/api/v1/reservations/999999\",\n                headers=headers,\n                timeout=TIMEOUT,\n            )\n            assert unauthorized_delete_resp.status_code in (403, 404), f\"Unauthorized deletion did not reject properly: {unauthorized_delete_resp.status_code}\"\n        \n        finally:\n            # Cleanup: in case deletion did not succeed above, attempt to delete the reservation\n            session.delete(\n                f\"{BASE_URL}/api/v1/reservations/{reservation_id}\",\n                headers=headers,\n                timeout=TIMEOUT,\n            )\n    except Exception:\n        traceback.print_exc()\n        raise\n    finally:\n        session.close()\n\ntest_delete_reservation_by_owner_user()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-22T04:45:04.513Z",
    "modified": "2025-12-22T04:45:42.603Z"
  },
  {
    "projectId": "28353356-24fd-44ef-901b-631dcecded48",
    "testId": "e9dc6533-2f29-4082-972d-995f91ae99ac",
    "userId": "8498b498-d001-7001-aca9-4f55c3b5bfec",
    "title": "TC010-get user appointments with access control",
    "description": "Test retrieving all appointments for a specific user ensuring that users can only view their own appointments unless they have ADMIN role, and invalid user IDs are handled properly.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3001\"\nAUTH_CREDENTIALS = (\"javier@jvha.com\", \"Pass1234\")\nTIMEOUT = 30\n\ndef test_get_user_appointments_with_access_control():\n    try:\n        # Step 1: Login to get JWT token\n        login_url = f\"{BASE_URL}/api/v1/auth/login\"\n        login_payload = {\n            \"email\": AUTH_CREDENTIALS[0],\n            \"password\": AUTH_CREDENTIALS[1]\n        }\n        login_resp = requests.post(login_url, json=login_payload, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n        token = login_resp.json().get(\"token\")\n        assert token and isinstance(token, str), \"JWT token not found in login response\"\n\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n\n        # Step 2: Get user info of logged in user to retrieve user id and role\n        # Assuming there is a protected route to get user profile\n        profile_url = f\"{BASE_URL}/api/v1/auth/protected-route\"  # Using protected-route as placeholder if no profile endpoint\n        profile_resp = requests.get(profile_url, headers=headers, timeout=TIMEOUT)\n        assert profile_resp.status_code == 200, \"Failed to access protected route to confirm authentication\"\n        # Since no user profile endpoint specified, we must try to get user id from reservations or appointments\n\n        # Workaround: Since no direct user info endpoint, try to get appointments with user's own id as unknown.\n        # So first we guess user id from a newly created reservation or skip to test access control for valid user ids.\n        # According to the PRD, user id param in path must be integer.\n\n        # For this test, we try to get appointments for the logged in user: first query with invalid user id should return 400.\n        invalid_user_id = \"invalid\"  # Non-integer user id\n        invalid_resp = requests.get(f\"{BASE_URL}/api/v1/users/{invalid_user_id}/appointments\", headers=headers, timeout=TIMEOUT)\n        assert invalid_resp.status_code == 400, f\"Expected 400 for invalid user ID but got {invalid_resp.status_code}\"\n\n        # Now test access control:\n        # Without user id knowledge, try values:\n        # Since user javier@jvha.com views his own appointments, get with user id as unknown should be denied or allowed accordingly.\n        # We'll try three cases:\n        # 1. User tries to get their own appointments -> expect 200\n        # 2. User tries to get another user's appointments -> expect 403\n\n        # To determine own user id, create a reservation and then get its user id through the reservation\n        # But PRD does not provide user info retrieval endpoint, only reservations endpoints\n\n        # Create time block as admin required, skip this, assume a timeBlockId=1 exists for testing reservation creation.\n        # Create a reservation to get known user id and reservation.\n        # We will create a reservation for the logged in user and fetch its appointments.\n\n        # We need an existing timeBlockId to create a reservation. Since we have no API to create time blocks except admin, \n        # and admin credentials not provided, we can't create a time block.\n        # So we test only with current info:\n        # Try to fetch from user id 1 (assuming javier is that user)\n\n        # Test fetching appointments for user id 1 (assuming javier's user id)\n        user_id_own = 1  # Assumed\n        appointments_resp = requests.get(f\"{BASE_URL}/api/v1/users/{user_id_own}/appointments\", headers=headers, timeout=TIMEOUT)\n        # User can see own appointments OR forbidden\n        assert appointments_resp.status_code in (200, 403), f\"Unexpected status {appointments_resp.status_code} when fetching own appointments\"\n        if appointments_resp.status_code == 200:\n            # Response should be a list/array of appointments\n            data = appointments_resp.json()\n            assert isinstance(data, list), \"Expected list of appointments for own user\"\n        elif appointments_resp.status_code == 403:\n            # If 403, user is not authorized to see own appointments (unlikely), could be test failure\n            assert False, \"Access denied for own appointments unexpectedly\"\n\n        # Test fetching appointments for a different user id (e.g. user_id_own + 1)\n        user_id_other = user_id_own + 1\n        other_resp = requests.get(f\"{BASE_URL}/api/v1/users/{user_id_other}/appointments\", headers=headers, timeout=TIMEOUT)\n        # Expect forbidden 403 or 200 if user is admin\n        if other_resp.status_code == 200:\n            # If user is admin, allowed\n            # We check if the token user is admin by presence of more than own appointments is unknown, skip role check\n            data = other_resp.json()\n            assert isinstance(data, list), \"Expected list of appointments for other user as admin\"\n        else:\n            assert other_resp.status_code == 403, f\"Expected 403 Forbidden for other user appointments but got {other_resp.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"RequestException occurred: {e}\"\n\ntest_get_user_appointments_with_access_control()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-22T04:45:04.525Z",
    "modified": "2025-12-22T04:45:48.573Z"
  }
]
